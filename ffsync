#!/usr/bin/env bash

configfile="ffsync.yml"
debug() { return 0; }

boldfont() { echo -en "\e[1m$@\e[0m"; } ## output text in bold font
err () { >&2 echo -e "\e[1;31m$@\e[0m"; }

yesno () { ## clean yes/no?
    echo -n " (y/n)? " 
    old_stty_cfg=$(stty -g); stty raw -echo
    answer=$( while ! head -c 1 | grep -i '[ny]' ; do true ; done )
    stty $old_stty_cfg
    if echo "$answer" | grep -iq "^y" ; then echo yes; return 0
    else echo no; return 1; fi
}

parse_yaml() {
# From https://gist.github.com/epiloque/8cf512c6d64641bde388
# Based on https://gist.github.com/pkuczynski/8665367

    local prefix=$2
    local s
    local w
    local fs
    s='[[:space:]]*'
    w='[a-zA-Z0-9_]*'
    fs="$(echo @|tr @ '\034')"
    sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
    awk -F"$fs" '{
    indent = length($1)/4;
    vname[indent] = $2;
    for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
            printf("%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, $3);
        }
    }' | sed 's/_=/+=/g'
}

modeselektor() {
    case "$1" in
        pull    )   mode="pull_filesystem" ;;
        push    )   mode="push_filesystem" ;;
        *       )   howdoiturnthison ;;
    esac
}

set_host() {
    if [ "$option_host" != "" ]; then
        host="$(echo $option_host | cut -d' ' -f1)"
    else
        cat_the_crap $default_hostfile host
        host="$(echo $host | cut -d' ' -f1)"
    fi
    test "$host" != "" || { err "\$host is empty!!" && exit 21 ;}
}

set_datadir() {
    export datadir="$(readlink -m $default_datadir)"
    test "$option_datadir" != "" && export datadir="$(readlink -m "$option_datadir")"
    test ! -f "$datadir" || { err "$datadir is an existing file. cannot use as \$datadir." && exit 22 ;}
}

set_filelist() { ## set $filelist
    export listfile="$default_listfile"
    test "$option_listfile" != "" && export listfile="$option_listfile"
    cat_the_crap $listfile filelist
    test "$filelist" != "" || { err "\$filelist is empty!!"; exit 22; }
}

set_variables() {
    set_host
    boldfont "Host:          " && echo "$host"

    set_datadir
    boldfont "Directory:     " && echo "$(readlink -f "$datadir")"

    test "$mode" = "pull" && {
        set_filelist
        boldfont "Files to pull: " && echo "$filelist"
    }

    if [ "$option_yess" != "true" ] && [ "$default_yess" != "true" ]; then
        echo -ne "\nOK"; yesno || exit 30
    fi
}

parse_arguments() {
# define beforehand: >$ parser_optlist=(1:one 2:two 3*three)
# where each option is: [X]{:/*}[...]
#       X   - option to look for
#       :/* - :additional argument or *only boolean
#       ... - name of variable to save to
#
# >$ parseargs -3 -1 "First Option" -2 SECOND
# .. would save "true" into a variable 'three', "First Option" into 'one'
#    and "SECOND" into 'two' when using above parser_optlist
    
    parser_optlist=(c:option_configfile h:option_host l:option_list d:option_datadir y*option_yess)

    for item in ${parser_optlist[@]}; do
        argument+=("$(echo $item | cut -c -2 | sed 's/*//')")
        variable+=("$(echo $item | cut -c 3-)")
    done;
    OPTIND=1;

    while getopts "$(echo ${argument[@]} | sed 's/ //g')" _opt; do
        for ((i = 0; i < ${#argument[@]}; i++)); do
            match="$(echo ${argument[$i]} | cut -c1)"
            if [ "$match" == "$_opt" ]; then
                if [ "$(echo ${argument[$i]} | cut -c2)" == ":" ];
                    then eval ${variable[$i]}="'$OPTARG'"
                    else eval ${variable[$i]}="true"; fi
                break
            fi
        done
    done
}

pull_filesystem() {
    test -d $datadir || mkdir $datadir

    boldfont "\nfetching files ..\n"
    # compresses to stdout remotely and pipes this to a local tar which extracts from stdin
    echo "ssh $host \"tar cpvzf - -C / $filelist\" | tar xpzf - -C $datadir"
}

push_filesystem() { ## script uploads ALL files in $datadir to $host
    test -d "$datadir" || { echo "directory $datadir does not exist." && exit 10 ;}
    test "$(ls -A "$datadir" 2>/dev/null)" || { echo "directory $datadir is empty." && exit 12 ;}

    boldfont "\npushing files ..\n"
    # compresses to stdout locally and pipes this to a remote tar which extracts from stdin
    echo "tar cpzf - -C $datadir . --owner=0 --group=0 | ssh $host \"tar xvzf - -C /\""
}

howdoiturnthison() { ## usage info
    fn="$(basename $0)"
    echo "
 $ $fn <mode> [-h host] [-d directory] [-l listfile] [-y]

<mode> is one of:
    push  - copy ALL files in \$datadir to the remote \$host
    pull  - copy the files listed in \$listfile from \$host and save to \$datadir

 \$host is read from ./host by default
 \$datadir is set to ./filesystem/ by default
 \$filelist is set to ./list by default

These variables can be overriden with the following options:
    [-h HOST] - connect to HOST instead
    [-d DIRECTORY] - use DIRECTORY for \$datadir instead
    [-l LISTFILE] - read the filelist from LISTFILE instead
    [-y] - override the confirmation dialog before action

This script only uses a single string as the remote host, so it is almost mandatory to have a corresponding hostconfig in ~/.ssh/ssh_config or /etc/ssh/ssh_config.

Example: Write the name of your host into ./host and a list of files / directories into ./list. Then execute:
    $ $fn pull -y

The script compresses all files with tar to stdout, pipes that through ssh, where another tar extracts from stdin. This preserves directory structure and you can directly push an entire structure to your host. However, when pushing uid and gid of all files are set to 0 (root) as this script was intended for router configuration backups, which usually only have one root user. Doing this bypasses the need for root locally and preserves proper file ownerships/permissions on the remote device.
"
    exit 1
}

cat_the_crap() {
    return 1
}

# ---------------------------------------------

# SELECT MODE OR SHOW HELP
modeselektor $1 && shift
debug && boldfont "mode $mode selected\n"

# PARSE ARGUMENTS ON CMDLINE
parse_arguments "$@"
debug && { boldfont "arguments parsed:\n"
for option in $(compgen -v | grep "^option"); do
    echo "$option = ${!option}"
done }

# PARSE YAML CONFIGFILE
eval $(parse_yaml $configfile "yamlconf_")
debug && { boldfont "YAML file parsed: (only first argument shown)\n"
for option in $(compgen -v | grep "^yamlconf_"); do
    echo "$option = ${!option}"
done }


set_variables

