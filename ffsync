#!/bin/bash

default_listfile="./list"
default_hostfile="./host"
default_fsdir="./filesystem"
default_yess="false"

boldfont() { echo -en "\e[1m$@\e[0m"; } ## output text in bold font
err () { >&2 echo -e "\e[1;31m$@\e[0m"; }

yesno () { ## clean yes/no?
    echo -n " (y/n)? " 
    old_stty_cfg=$(stty -g); stty raw -echo
    answer=$( while ! head -c 1 | grep -i '[ny]' ; do true ; done )
    stty $old_stty_cfg
    if echo "$answer" | grep -iq "^y" ; then echo yes; return 0
    else echo no; return 1; fi
}

cat_the_crap() { ## parse a file and cut all comments (everything after a '#')
    local result="$2"
    if [ -f "$1" ]; then
        local cleaned="$(cat $1 | sed -r 's/(^| )#.*//' | xargs)"
        eval $result="'$cleaned'"
    else err "$1 does not exist."; exit 10; fi
}

modeselektor() { ## decide mode of operation
    export mode="$1" && shift
    case "$mode" in
        pull    )   pull_filesystem $@ ;;
        push    )   push_filesystem $@ ;;
        *       )   howdoiturnthison ;;
    esac
}

set_host() { ## set $host
    if [ "$option_host" != "" ]; then
        host="$(echo $option_host | cut -d' ' -f1)"
    else
        cat_the_crap $default_hostfile host
        host="$(echo $host | cut -d' ' -f1)"
    fi
    test "$host" != "" || { err "\$host is empty!!" && exit 21 ;}
}

set_fsdir() { ## set $fsdir
    export fsdir="$(readlink -m $default_fsdir)"
    test "$option_fsdir" != "" && export fsdir="$(readlink -m "$option_fsdir")"
    test ! -f "$fsdir" || { err "$fsdir is an existing file. cannot use as \$fsdir." && exit 22 ;}
}

set_filelist() { ## set $filelist
    export listfile="$default_listfile"
    test "$option_listfile" != "" && export listfile="$option_listfile"
    cat_the_crap $listfile filelist
    test "$filelist" != "" || { err "\$filelist is empty!!"; exit 22; }
}

set_variables() {
    set_host
    boldfont "Host:          " && echo "$host"

    set_fsdir
    boldfont "Directory:     " && echo "$(readlink -f "$fsdir")"

    test "$mode" = "pull" && {
        set_filelist
        boldfont "Files to pull: " && echo "$filelist"
    }

    if [ "$option_yess" != "true" ] && [ "$default_yess" != "true" ]; then
        echo -ne "\nOK"; yesno || exit 30
    fi
}

parse_args() { ## parse arguments as options
# define beforehand: >$ parser_optlist=(1:one 2:two 3*three)
# where each option is: [X]{:/*}[...]
#       X   - option to look for
#       :/* - :additional argument or *only boolean
#       ... - name of variable to save to
#
# >$ parseargs -3 -1 "First Option" -2 SECOND
# .. would save "true" into a variable 'three', "First Option" into 'one'
#    and "SECOND" into 'two' when using above parser_optlist
    
    parser_optlist=(h:option_host l:option_listfile d:option_fsdir y*option_yess)

    for item in ${parser_optlist[@]}; do
        argument+=("$(echo $item | cut -c -2 | sed 's/*//')")
        variable+=("$(echo $item | cut -c 3-)")
    done;
    OPTIND=1;

    while getopts "$(echo ${argument[@]} | sed 's/ //g')" _opt; do
        for ((i = 0; i < ${#argument[@]}; i++)); do
            match="$(echo ${argument[$i]} | cut -c1)"
            if [ "$match" == "$_opt" ]; then
                if [ "$(echo ${argument[$i]} | cut -c2)" == ":" ];
                    then eval ${variable[$i]}="'$OPTARG'"
                    else eval ${variable[$i]}="true"; fi
                break
            fi
        done
    done
}

pull_filesystem() {
    parse_args $@
    set_variables

    test -d $fsdir || mkdir $fsdir

    boldfont "\nfetching files ..\n"
    # compresses to stdout remotely and pipes this to a local tar which extracts from stdin
    ssh $host "tar cpvzf - -C / $filelist" | tar xpzf - -C $fsdir
}

push_filesystem() { ## script uploads ALL files in $fsdir to $host
    parse_args $@
    set_variables

    test -d "$fsdir" || { echo "directory $fsdir does not exist." && exit 10 ;}
    test "$(ls -A "$fsdir" 2>/dev/null)" || { echo "directory $fsdir is empty." && exit 12 ;}

    boldfont "\npushing files ..\n"
    # compresses to stdout locally and pipes this to a remote tar which extracts from stdin
    tar cpzf - -C $fsdir . --owner=0 --group=0 | ssh $host "tar xvzf - -C /"
}

howdoiturnthison() { ## usage info
    fn="$(basename $0)"
    echo "
 $ $fn <mode> [-h host] [-d directory] [-l listfile] [-y]

<mode> is one of:
    push  - copy ALL files in \$fsdir to the remote \$host
    pull  - copy the files listed in \$listfile from \$host and save to \$fsdir

 \$host is read from ./host by default
 \$fsdir is set to ./filesystem/ by default
 \$filelist is set to ./list by default

These variables can be overriden with the following options:
    [-h HOST] - connect to HOST instead
    [-d DIRECTORY] - use DIRECTORY for \$fsdir instead
    [-l LISTFILE] - read the filelist from LISTFILE instead
    [-y] - override the confirmation dialog before action

This script only uses a single string as the remote host, so it is almost mandatory to have a corresponding hostconfig in ~/.ssh/ssh_config or /etc/ssh/ssh_config.

Example: Write the name of your host into ./host and a list of files / directories into ./list. Then execute:
    $ $fn pull -y

The script compresses all files with tar to stdout, pipes that through ssh, where another tar extracts from stdin. This preserves directory structure and you can directly push an entire structure to your host. However, when pushing uid and gid of all files are set to 0 (root) as this script was intended for router configuration backups, which usually only have one root user. Doing this bypasses the need for root locally and preserves proper file ownerships/permissions on the remote device.
"
}

## main () {
modeselektor $@
