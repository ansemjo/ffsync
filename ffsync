#!/usr/bin/env bash

default_configfile="ffsync.yml"
debug() { return 0; }

boldfont() { echo -en "\e[1m$@\e[0m"; } ## output text in bold font
err () { >&2 echo -e "\e[1;31m$@\e[0m"; }


# YES NO QUESTION
yesno () {
    echo -n " (y/n)? " 
    old_stty_cfg=$(stty -g); stty raw -echo
    answer=$( while ! head -c 1 | grep -i '[ny]' ; do true ; done )
    stty $old_stty_cfg
    if echo "$answer" | grep -iq "^y" ; then echo yes; return 0
    else echo no; return 1; fi
}


# PARSE ARGUMENTS ON CMDLINE
parse_arguments() {
# define beforehand: >$ parser_optlist=(1:one 2:two 3*three)
# where each option is: [X]{:/*}[...]
#       X   - option to look for
#       :/* - :additional argument or *only boolean
#       ... - name of variable to save to
#
# >$ parseargs -3 -1 "First Option" -2 SECOND
# .. would save "true" into a variable 'three', "First Option" into 'one'
#    and "SECOND" into 'two' when using above parser_optlist
    
    parser_optlist=(c:option_configfile h:option_hostname l:option_filelist d:option_datadir y*option_yesyes)

    for item in ${parser_optlist[@]}; do
        argument+=("$(echo $item | cut -c -2 | sed 's/*//')")
        variable+=("$(echo $item | cut -c 3-)")
    done;
    OPTIND=1;

    while getopts "$(echo ${argument[@]} | sed 's/ //g')" _opt; do
        for ((i = 0; i < ${#argument[@]}; i++)); do
            match="$(echo ${argument[$i]} | cut -c1)"
            if [ "$match" == "$_opt" ]; then
                if [ "$(echo ${argument[$i]} | cut -c2)" == ":" ];
                    then eval ${variable[$i]}="'$OPTARG'"
                    else eval ${variable[$i]}="true"; fi
                break
            fi
        done
    done
}


# PARSE YAML FILES
parse_yaml() {
# From https://gist.github.com/epiloque/8cf512c6d64641bde388
# Based on https://gist.github.com/pkuczynski/8665367

    local prefix=$2
    local s
    local w
    local fs
    s='[[:space:]]*'
    w='[a-zA-Z0-9_]*'
    fs="$(echo @|tr @ '\034')"
    sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
    awk -F"$fs" '{
    indent = length($1)/4;
    vname[indent] = $2;
    for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
            printf("%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, $3);
        }
    }' | sed 's/_=/+=/g'
}


# SET SSH REMOTE HOST
set_host() {
    if [ "$option_host" != "" ]; then
        host="$(echo $option_host | cut -d' ' -f1)"
    else
        cat_the_crap $default_hostfile host
        host="$(echo $host | cut -d' ' -f1)"
    fi
    test "$host" != "" || { err "\$host is empty!!" && exit 21 ;}
}


# SET FILESYSTEM DIRECTORY
set_datadir() {
    export datadir="$(readlink -m $default_datadir)"
    test "$option_datadir" != "" && export datadir="$(readlink -m "$option_datadir")"
    test ! -f "$datadir" || { err "$datadir is an existing file. cannot use as \$datadir." && exit 22 ;}
}


# SET LIST OF FILES TO FETCH/PUSH
set_filelist() {
    export listfile="$default_listfile"
    test "$option_listfile" != "" && export listfile="$option_listfile"
    cat_the_crap $listfile filelist
    test "$filelist" != "" || { err "\$filelist is empty!!"; exit 22; }
}


# UNIVERSALLY SET VARIABLE
set_variable() {
    for priority in option yamlconf default; do
        local va="${priority}_$1[@]"
        if [ "$(echo ${!va})" != "" ]; then
            err "set_variable $1: $va --> '${!va}'"
            eval export $1="'${!va}'"
            return 0
        fi
    done
    err "no value for '$1'! abort."
    exit 1
}


# SET ALL VARIABLES
set_variables() {
    set_host
    boldfont "Host:          " && echo "$host"

    set_datadir
    boldfont "Directory:     " && echo "$(readlink -f "$datadir")"

    test "$mode" = "pull" && {
        set_filelist
        boldfont "Files to pull: " && echo "$filelist"
    }

    if [ "$option_yess" != "true" ] && [ "$default_yess" != "true" ]; then
        echo -ne "\nOK"; yesno || exit 30
    fi
}


# FETCH FILES
pull_filesystem() {
    test -d $datadir || mkdir $datadir

    boldfont "\nfetching files ..\n"
    # compresses to stdout remotely and pipes this to a local tar which extracts from stdin
    echo "ssh $host \"tar cpvzf - -C / $filelist\" | tar xpzf - -C $datadir"
}


# PUSH FILES
push_filesystem() { ## script uploads ALL files in $datadir to $host
    test -d "$datadir" || { echo "directory $datadir does not exist." && exit 10 ;}
    test "$(ls -A "$datadir" 2>/dev/null)" || { echo "directory $datadir is empty." && exit 12 ;}

    boldfont "\npushing files ..\n"
    # compresses to stdout locally and pipes this to a remote tar which extracts from stdin
    echo "tar cpzf - -C $datadir . --owner=0 --group=0 | ssh $host \"tar xvzf - -C /\""
}


# HELPFUL INFORMATION
howdoiturnthison() { ## usage info
    fn="$(basename $0)"
    echo "
 $ $fn <mode> [-h host] [-d directory] [-l listfile] [-y]

<mode> is one of:
    push  - copy ALL files in \$datadir to the remote \$host
    pull  - copy the files listed in \$listfile from \$host and save to \$datadir

 \$host is read from ./host by default
 \$datadir is set to ./filesystem/ by default
 \$filelist is set to ./list by default

These variables can be overriden with the following options:
    [-h HOST] - connect to HOST instead
    [-d DIRECTORY] - use DIRECTORY for \$datadir instead
    [-l LISTFILE] - read the filelist from LISTFILE instead
    [-y] - override the confirmation dialog before action

This script only uses a single string as the remote host, so it is almost mandatory to have a corresponding hostconfig in ~/.ssh/ssh_config or /etc/ssh/ssh_config.

Example: Write the name of your host into ./host and a list of files / directories into ./list. Then execute:
    $ $fn pull -y

The script compresses all files with tar to stdout, pipes that through ssh, where another tar extracts from stdin. This preserves directory structure and you can directly push an entire structure to your host. However, when pushing uid and gid of all files are set to 0 (root) as this script was intended for router configuration backups, which usually only have one root user. Doing this bypasses the need for root locally and preserves proper file ownerships/permissions on the remote device.
"
    exit 1
}


# DELETEME
cat_the_crap() {
    return 1
}

# ---------------------------------------------

# SELECT MODE OR SHOW HELP
case "$1" in
    pull    )   mode="pull_filesystem" ;;
    push    )   mode="push_filesystem" ;;
    *       )   howdoiturnthison ;;
esac; shift
debug && boldfont "mode $mode selected\n"

# PARSE ARGUMENTS ON CMDLINE
parse_arguments "$@"
debug && { boldfont "arguments parsed:\n"
for option in $(compgen -v | grep "^option"); do
    echo "$option = ${!option}"
done }

set_variable configfile

# PARSE YAML CONFIGFILE
eval $(parse_yaml "$configfile" "yamlconf_")
debug && { boldfont "YAML file parsed: (only first argument shown)\n"
for option in $(compgen -v | grep "^yamlconf_"); do
    echo "$option = ${!option}"
done }

for vn in datadir hostname filelist; do
    set_variable $vn
done

boldfont "parsed all vars:
configfile:     $configfile
datadir:        $datadir
hostname:       $hostname
filelist:       $filelist
"
