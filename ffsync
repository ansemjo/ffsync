#!/bin/bash

# Author:   anton@semjonov.de
# Date:     january 2016

export _listfile="list"
export _hostfile="host"
export _fsdir="filesystem"
export _beVerbose="no"

timestamp() { echo "$(date +%F--%H-%M-%S-%Z)"; } ## echo timestamp like: 2016-01-12--00-36-10-CET
export tarball="ffsync-$(timestamp).tar.gz"

waitkey() { local void; read -rsp $'Press any key to continue...\n' -n1 void; } ## wait on any keypress ..
verbose() { test "$_beVerbose" = "yes"; } ## test wether to be verbose?
boldfont() { echo -en "\e[1m$@\e[0m"; } ## output arguments in bold font

yesno () { ## POSIX-compliant yes/no?
    echo -n " (y/n)? " 
    old_stty_cfg=$(stty -g); stty raw -echo
    answer=$( while ! head -c 1 | grep -i '[ny]' ; do true ; done )
    stty $old_stty_cfg
    if echo "$answer" | grep -iq "^y" ; then echo yes; return 0
    else echo no; return 1; fi
}

cat_the_crap() { ## parse a file and cut all comments (evereything after a '#')
    test "$1" != "" && test -f "$1" || return 0
    cat "$1" | sed -r 's/(^| )#.*//' | xargs
}

set_filelist() { ## set $filelist
    test "$optlistfile" != "" && if test -f "$optlistfile"; then 
        export _listfile="$optlistfile"; else echo "$optlistfile does not exist" && exit 2; fi
    export filelist="$(cat_the_crap $_listfile)"
    verbose && boldfont "building file list from $_listfile...\n" && echo -e "$filelist\n" && waitkey
    test "$filelist" = "" && echo "\$filelist is empty!!" && exit 3
}

set_host() { ## set $host
    test "$opthost" != "" && export host="$(echo $opthost | cut -d' ' -f1)" && return 0
    export host="$(cat_the_crap $_hostfile | cut -d' ' -f1)"
    verbose && boldfont "getting host ... " && echo $host && waitkey
    test "$host" = "" && echo "\$host is empty!!" && exit 4
}

set_fsdir() { ## set $fsdir
    if test "$optfsdir" != ""; then
        export optfsdir="$(echo $optfsdir | sed 's|[/]*$||')"
        if test -f "$optfsdir"; then
            echo "$optfsdir exists and is a file!!" && exit 5
        elif test -d "$optfsdir"; then
            echo -n "will use $optfsdir. (overwrites when pulling!) ok"
            yesno && export fsdir="$optfsdir" || exit 6
        else export fsdir="$optfsdir"; fi
    fi
    test "$fsdir" != "" || export fsdir="$_fsdir"
}

set_variables() {
    set_host
    set_filelist
    set_fsdir

    boldfont "Host:          " && echo "$host"
    boldfont "Directory:     " && echo "$(readlink -f "$fsdir")"
    boldfont "Tarball name:  " && echo "$tarball"
    boldfont "Files to sync: " && echo "$filelist"
}

modeselektor() { ## decide mode of operation
    export mode="$1" && shift

    case "$mode" in
        pull    )   parseargs $@ && pull_filesystem ;;
        push    )   parseargs $@ && push_filesystem ;;
        *       )   howdoiturnthison ;;
    esac
}

howdoiturnthison() { ## usage info
    echo "Use some cheats? I don't know ..."
}

parseargs() { ## parse arguments as options
# define beforehand: >$ export parser_optlist=(1:one 2:two 3*three)
# where each option is: [X]{:/*}[...]
#       X   - option to look for
#       :/* - :additional argument or *only boolean
#       ... - name of variable to save to
#
# >$ parseargs -3 -1 "First Option" -2 SECOND
# .. would save "true" into a variable 'three', "First Option" into 'one'
#    and "SECOND" into 'two' when using above parser_optlist
    
    export parser_optlist=(h:opthost l:optlistfile d:optfsdir)

    for item in ${parser_optlist[@]}; do
        argument+=("$(echo $item | cut -c -2 | sed 's/*//')")
        variable+=("$(echo $item | cut -c 3-)")
    done; OPTIND=1;

    while getopts "$(echo ${argument[@]} | sed 's/ //g')" _opt; do
        for ((i = 0; i <= ${#argument}; i++)); do
            match="$(echo ${argument[$i]} | cut -c1)"
            if [ "$match" == "$_opt" ]; then
                if [ "$(echo ${argument[$i]} | cut -c2)" == ":" ]; then
                    eval ${variable[$i]}="'$OPTARG'"
                else
                    eval ${variable[$i]}="true"
                fi
                break
            fi
        done
    done
}

pull_filesystem () {
    set_variables

    # CREATE REMOTE TARBALL
    boldfont "\ncreating tarball remotely in /tmp ..\n"
    ssh $host -t tar -cpvz -C / -f /tmp/$tarball $filelist

    # MOVE TARBALL TO LOCAL MACHINE
    boldfont "\ncopying file to local machine ..\n"
    scp $host:/tmp/$tarball ./
    ssh $host -qt rm -f /tmp/$tarball && echo "removed remote copy .."

    # EXTRACT TARBALL LOCALLY
    boldfont "\nextracting tarball locally ..\n"
    test -d $fsdir || mkdir $fsdir
    tar -xpvz -C $fsdir -f $tarball && rm $tarball || echo "ERROR when extracting! tarball remains: $(readlink -f $tarball)"

}

push_filesystem () { ## script uploads ALL files in $fsdir to $host
    set_variables

    # MAKE LOCAL TARBALL
    boldfont "\ncreating tarball locally ..\n"
    if [ "$(ls -A "$fsdir")" ]; then
     tar -cpvz -C $fsdir -f $tarball . --owner=0 --group=0
    else
     echo "no files found .. was looking for $fsdir"
     exit 1
    fi

    # MOVE TARBALL TO REMOTE MACHINE
    boldfont "\nmoving tarball to remote /tmp ..\n"
    scp $tarball $host:/tmp/ && rm -f ./$tarball

    # EXTRACT REMOTELY
    boldfont "\nextracting tarball remotely ..\n"
    ssh $host -t "tar -xvz -C / -f /tmp/$tarball && rm -f /tmp/$tarball"
}

## main () {
modeselektor $@
